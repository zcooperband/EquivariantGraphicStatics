import math
import numpy as np
from scipy.linalg import null_space
from scipy.linalg import orth
from scipy.linalg import svd
from matplotlib import pyplot as plt

#########################################################################################
### Homology Function ###################################################################
#########################################################################################


def homology(outmap, inmap):
    if inmap.shape[0] != outmap.shape[1]:
        print("Homology error: maps don't compose")
        print("inmap dimension: ",inmap.shape[0])
        print("outmap dimension: ",outmap.shape[1])
    elif np.sum(np.dot(outmap,inmap)) > 0.00000001:
        print("Homology error: maps don't compose to 0")
    else:
        # Gives the cokernel of \bdd_{i+1}
        if inmap.size == 0 or orth(inmap).size == 0:
            coker = np.identity(inmap.shape[0])
        else:
            coker = null_space(orth(inmap).T)
        # Finds nullspace of \bdd on coker, in terms of coker vectors
        if outmap.size == 0 or coker.size ==0:
            H = coker
        else:
            H = np.dot(coker, null_space(np.dot(outmap, coker)) )
        return H


#########################################################################################
### Constant Cosheaf ####################################################################
#########################################################################################


class constant_cosheaf:
    def __init__(self, cell_complex, group_action):
        self.cell_complex = cell_complex
        self.group_action = group_action
    
    def stalk_dim(self, dim):
        if dim == 0 or dim == 1 or dim == 2:return 2
        else:return 0
        
    def bdd(self, dim):
        #Returns the boundary matrix for the cosheaf of dimension (dim)
        inum = self.stalk_dim(dim-1) * self.cell_complex.num(dim-1)
        jnum = self.stalk_dim(dim) * self.cell_complex.num(dim)
        bdd = np.zeros((inum, jnum))
        adj = self.cell_complex.adj(dim)
        if dim == 2:
            for i in range(0, self.cell_complex.num(1)):
                for j in range(0, self.cell_complex.num(2)):
                    bdd[2*i:2*(i + 1), 2*j: 2*(j+1)] = adj[i, j]*np.identity(2)       
        elif dim == 1:
            for i in range(0, self.cell_complex.num(0)):
                for j in range(0, self.cell_complex.num(1)):
                    bdd[2*i: 2*(i + 1), 2*j:2*(j+1)] = adj[i, j]*np.identity(2)
        return bdd
    
    def representation(self, dim, index):
        #Returns the representation matrix for the cosheaf of dimension (dim) at the (index) group element
        inum = self.stalk_dim(dim) * self.cell_complex.num(dim)
        matx = np.zeros((inum, inum))
        if dim == 2:
            permutation = face_permutation(self.group_action, self.cell_complex.faces, index)
            for j in range(0, self.cell_complex.num(dim)):
                i, sign = permutation[j]
                matx[2*i:2*(i+1), 2*j:2*(j+1)] = sign * self.group_action.matrix(index)
        elif dim == 1:
            permutation = edge_permutation(self.group_action, self.cell_complex.edges, index)
            for j in range(0, self.cell_complex.num(dim)):
                i, sign = permutation[j]
                matx[2*i:2*(i+1), 2*j:2*(j+1)] = sign * self.group_action.matrix(index)
        elif dim == 0:
            permutation = self.group_action.vert_permutation(index)
            for j in range(0, self.cell_complex.num(dim)):
                i, sign = permutation[j]
                matx[2*i:2*(i+1), 2*j:2*(j+1)] = sign * self.group_action.matrix(index)
        return matx
    
    def to_next_cosheaf_map(self, dim):
        inum = dim * self.cell_complex.num(dim)
        jnum = self.stalk_dim(dim) * self.cell_complex.num(dim)
        psi = np.zeros((inum, jnum))
        if dim == 2:
            for i in range(0, self.cell_complex.num(2)):
                psi[2*i:2*(i+1), 2*i:2*(i+1)] = np.eye(2)
        if dim == 1:
            for i in range(0, self.cell_complex.num(1)):
                psi[i, 2*i : 2*(i + 1)] = self.cell_complex.perp_edge_norm(i)
        return psi
    
    def irred_char(self, dim, basis):
        #Returns a list of irreducible character components of the subspace generated by the basis vectors
        #(dim) is the dimension of the cosheaf representation
        #(basis) should be an array of ortho-normal column vectors spanning the invariant subspace of chains
        char = np.zeros(self.group_action.order)
        for j in range(0, self.group_action.order):
            rep = self.representation(dim, j)
            subrep = np.dot(basis.T, np.dot(rep, basis))
            char[j] = np.trace(subrep)
        return self.group_action.char_inner_product(char)
    
    def chain_irred_char(self, dim):
        basis = np.identity(self.stalk_dim(dim)*self.cell_complex.num(dim))
        return self.irred_char(dim, basis)
    def homology_irred_char(self, dim):
        basis = self.homology(dim)
        return self.irred_char(dim, basis)
    
    def irred_basis(self, dim, basis):
        #Splits (basis) into component bases corresponding to the irreducibles
        #Returns (Bases), a dictionary where the [char_num] position are the components of (basis)
        #Output is in (basis) space; to recover the full vector do np.dot(basis, Bases)
        Bases = {}
        char_table = self.group_action.full_char_table()
        for i in range(0, self.group_action.num_conjugacy_classes()):
            inum = self.stalk_dim(dim) * self.cell_complex.num(dim)
            matx = np.zeros((inum, inum), dtype = complex)
            for j in range(0, self.group_action.order):
                matx += char_table[i, j] * self.representation(dim, j)
            X = np.dot(matx, basis) #orth(X) freaks out, so we manually delete low singular values
            if X.shape[1] > 0:
                U, S, V = svd(X)
                for k in range(0, X.shape[1]):
                    if abs(S[k]) < 0.000000000001:
                        X[:,k] = [0] * X.shape[0]
                Bases[i] = np.dot(basis.T, orth(X))
        return Bases
    
    def chain_irred_basis(self, dim):
        basis = np.identity(self.stalk_dim(dim)*self.cell_complex.num(dim))
        return self.irred_basis(dim, basis)
    def homology_irred_basis(self, dim):
        basis = self.homology(dim)
        return self.irred_basis(dim, basis)
    
    def homology(self, dim):
        return homology(self.bdd(dim), self.bdd(dim + 1))
    def homology_dim(self,dim):
        H = homology(self.bdd(dim), self.bdd(dim + 1))
        return H.shape[1]


#########################################################################################
### Force Cosheaf #######################################################################
#########################################################################################

class force_cosheaf:
    def __init__(self, cell_complex, group_action):
        self.cell_complex = cell_complex
        self.group_action = group_action
    
    def stalk_dim(self, dim):
        if dim == 1:return 1
        elif dim == 0:return 2
        else:return 0
        
    def bdd(self, dim):
        #Returns the boundary matrix for the cosheaf of dimension (dim)
        inum = self.stalk_dim(dim-1) * self.cell_complex.num(dim-1)
        jnum = self.stalk_dim(dim) * self.cell_complex.num(dim)
        bdd = np.zeros((inum, jnum))
        adj = self.cell_complex.adj(dim)
        if dim == 1:
            for i in range(0, self.cell_complex.num(0)):
                for j in range(0, self.cell_complex.num(1)):
                    bdd[2 * i: 2 * (i + 1), j] = adj[i, j] * self.cell_complex.edge_norm(j).T
        return bdd

    def representation(self, dim, index):
        #Returns the representation matrix for the cosheaf of dimension (dim) at the (index) group element
        inum = self.stalk_dim(dim) * self.cell_complex.num(dim)
        matx = np.zeros((inum, inum))
        if dim == 1:
            permutation = edge_permutation(self.group_action, self.cell_complex.edges, index)
            for j in range(0, self.cell_complex.num(dim)):
                i, sign = permutation[j]
                matx[i, j] = 1
        elif dim == 0:
            permutation = self.group_action.vert_permutation(index)
            for j in range(0, self.cell_complex.num(dim)):
                i, sign = permutation[j]
                matx[2*i:2*(i+1), 2*j:2*(j+1)] = sign * self.group_action.matrix(index)
        return matx
    
    def to_next_cosheaf_map(self, dim):
        inum = 2 * self.cell_complex.num(dim)
        jnum = self.stalk_dim(dim) * self.cell_complex.num(dim)
        phi = np.zeros((inum, jnum))
        if dim == 1:
            for i in range(0, self.cell_complex.num(1)):
                phi[2 * i: 2 * (i + 1), i] = self.cell_complex.edge_norm(i).T
        if dim == 0:
            for i in range(0, self.cell_complex.num(0)):
                phi[2*i:2*(i + 1), 2*i:2*(i+1)] = np.eye(2)
        return phi
    
    def homology(self, dim):
        return homology(self.bdd(dim), self.bdd(dim + 1))
    def homology_dim(self,dim):
        H = homology(self.bdd(dim), self.bdd(dim + 1))
        return H.shape[1]
    
    def irred_char(self, dim, basis):
        #Returns a list of irreducible character components of the subspace generated by the basis vectors
        #(dim) is the dimension of the cosheaf representation
        #(basis) should be an array of ortho-normal column vectors spanning the invariant subspace of chains
        char = np.zeros(self.group_action.order)
        for j in range(0, self.group_action.order):
            rep = self.representation(dim, j)
            subrep = np.dot(basis.T, np.dot(rep, basis))
            char[j] = np.trace(subrep)
        return self.group_action.char_inner_product(char)
    
    def chain_irred_char(self, dim):
        basis = np.identity(self.stalk_dim(dim)*self.cell_complex.num(dim))
        return self.irred_char(dim, basis)
    def homology_irred_char(self, dim):
        basis = self.homology(dim)
        return self.irred_char(dim, basis)
    
    def irred_basis(self, dim, basis):
        #Splits (basis) into component bases corresponding to the irreducibles
        #Returns (Bases), a dictionary where the [char_num] position are the components of (basis)
        #Output is in (basis) space; to recover the full vector do np.dot(basis, Bases)
        Bases = {}
        char_table = self.group_action.full_char_table()
        for i in range(0, self.group_action.num_conjugacy_classes()):
            inum = self.stalk_dim(dim) * self.cell_complex.num(dim)
            matx = np.zeros((inum, inum), dtype = complex)
            for j in range(0, self.group_action.order):
                matx += char_table[i, j] * self.representation(dim, j)
            X = np.dot(matx, basis) #orth(X) freaks out, so we manually delete low singular values
            if X.shape[1] > 0:
                U, S, V = svd(X)
                for k in range(0, X.shape[1]):
                    if abs(S[k]) < 0.000000000001:
                        X[:,k] = [0] * X.shape[0]
                Bases[i] = np.dot(basis.T, orth(X))
        return Bases
    
    def chain_irred_basis(self, dim):
        basis = np.identity(self.stalk_dim(dim)*self.cell_complex.num(dim))
        return self.irred_basis(dim, basis)
    def homology_irred_basis(self, dim):
        basis = self.homology(dim)
        return self.irred_basis(dim, basis)
    
    def plot_self_stress(self, posvec):
        H1 = self.homology(1)
        stress = np.dot(H1, posvec)
        fig, ax1 = plt.subplots()

        for i in range(0, self.cell_complex.num(0)):
            X = self.cell_complex.totcoords[i][0]
            Y = self.cell_complex.totcoords[i][1]
            ax1.text(X, Y, i)
            ax1.scatter(X,Y)

        for i in range(0, self.cell_complex.num(1)):
            edge = self.cell_complex.edges[i]
            edgex = [self.cell_complex.totcoords[edge[0], 0], self.cell_complex.totcoords[edge[1], 0] ]
            edgey = [self.cell_complex.totcoords[edge[0], 1], self.cell_complex.totcoords[edge[1], 1] ]
            if stress[i] < -0.000001:
                ax1.plot(edgex, edgey, color='blue')
            elif stress[i] > 0.000001:
                ax1.plot(edgex, edgey, color='red')
            else:
                ax1.plot(edgex, edgey, color = 'black')
        ax1.set_title('Self Stress')
        print("Blue edges in tension, red edges in compression.")
        plt.show()


#########################################################################################
### Position Cosheaf##### ###############################################################
#########################################################################################


class position_cosheaf:
    def __init__(self, cell_complex, group_action):
        self.cell_complex = cell_complex
        self.group_action = group_action
    
    def stalk_dim(self, dim):
        if dim == 2:return 2
        elif dim == 1:return 1
        else:return 0
        
    def bdd(self, dim):
        #Returns the boundary matrix for the cosheaf of dimension (dim)
        inum = self.stalk_dim(dim-1) * self.cell_complex.num(dim-1)
        jnum = self.stalk_dim(dim) * self.cell_complex.num(dim)
        bdd = np.zeros((inum, jnum))
        adj = self.cell_complex.adj(dim)
        if dim == 2:
            for i in range(0, self.cell_complex.num(1)):
                for j in range(0, self.cell_complex.num(2)):
                    bdd[i, 2*j : 2*(j + 1)] = adj[i,j] * self.cell_complex.perp_edge_norm(i)
        return bdd
    
    def representation(self, dim, index):
        #Returns the representation matrix for the cosheaf of dimension (dim) at the (index) group element
        inum = self.stalk_dim(dim) * self.cell_complex.num(dim)
        matx = np.zeros((inum, inum))
        if dim == 2:
            permutation = face_permutation(self.group_action, self.cell_complex.faces, index)
            for j in range(0, self.cell_complex.num(dim)):
                i, sign = permutation[j]
                matx[2*i:2*(i+1), 2*j:2*(j+1)] = sign * self.group_action.matrix(index)
        elif dim == 1:
            permutation = edge_permutation(self.group_action, self.cell_complex.edges, index)
            for j in range(0, self.cell_complex.num(dim)):
                i, sign = permutation[j]
                matx[i, j] = 1
                if index >= self.group_action.rot_order: #If this is a flip
                    matx[i,j] *= -1
        return matx

    def homology(self, dim):
        return homology(self.bdd(dim), self.bdd(dim + 1))
    def homology_dim(self,dim):
        H = homology(self.bdd(dim), self.bdd(dim + 1))
        return H.shape[1]
    
    def irred_char(self, dim, basis):
        #Returns a list of irreducible character components of the subspace generated by the basis vectors
        #(dim) is the dimension of the cosheaf representation
        #(basis) should be an array of ortho-normal column vectors spanning the invariant subspace of chains
        char = np.zeros(self.group_action.order)
        for j in range(0, self.group_action.order):
            rep = self.representation(dim, j)
            subrep = np.dot(basis.T, np.dot(rep, basis))
            char[j] = np.trace(subrep)
        return self.group_action.char_inner_product(char)
    
    def chain_irred_char(self, dim):
        basis = np.identity(self.stalk_dim(dim)*self.cell_complex.num(dim))
        return self.irred_char(dim, basis)
    def homology_irred_char(self, dim):
        basis = self.homology(dim)
        return self.irred_char(dim, basis)
    
    def irred_basis(self, dim, basis):
        #Splits (basis) into component bases corresponding to the irreducibles
        #Returns (Bases), a dictionary where the [char_num] position are the components of (basis)
        #Output is in (basis) space; to recover the full vector do np.dot(basis, Bases)
        Bases = {}
        char_table = self.group_action.full_char_table()
        for i in range(0, self.group_action.num_conjugacy_classes()):
            inum = self.stalk_dim(dim) * self.cell_complex.num(dim)
            matx = np.zeros((inum, inum), dtype = complex)
            for j in range(0, self.group_action.order):
                matx += char_table[i, j] * self.representation(dim, j)
            X = np.dot(matx, basis) #orth(X) freaks out, so we manually delete low singular values
            if X.shape[1] > 0:
                U, S, V = svd(X)
                for k in range(0, X.shape[1]):
                    if abs(S[k]) < 0.000000000001:
                        X[:,k] = [0] * X.shape[0]
                Bases[i] = np.dot(basis.T, orth(X))
        return Bases
    
    def chain_irred_basis(self, dim):
        basis = np.identity(self.stalk_dim(dim)*self.cell_complex.num(dim))
        return self.irred_basis(dim, basis)
    def homology_irred_basis(self, dim):
        basis = self.homology(dim)
        return self.irred_basis(dim, basis)
    
    def remove_constant_component(self, posvecs):
        if posvecs.shape[1] > 0:
            const = np.zeros((2, 2 * self.cell_complex.num(2)))
            for i in range(0,self.cell_complex.num(2)):
                if self.cell_complex.face_orientation(i):
                    sign = 1
                else: sign = -1
                const[:, 2*i : 2*(i+1)] = sign * np.identity(2)
            const_proj = np.dot(const, self.homology(2))
            nullsp = null_space(const_proj)
            return (np.dot(nullsp, np.dot(nullsp.T, posvecs)))
        else: return np.zeros((posvecs.shape[0], 0))
    
    def connecting_hom_2(self):
        #Returns the matrix for the connecting homomorphism from 2nd G homology to 1st F homology
        connecting_hom = np.zeros((1*self.cell_complex.num(1), 2*self.cell_complex.num(2)))
        adj = self.cell_complex.adj(2)
        for i in range(0, self.cell_complex.num(1)):
            for j in range(0, self.cell_complex.num(2)):
                connecting_hom[i, 2*j:2*(j+1)] = adj[i, j]* self.cell_complex.edge_norm(i)
        return connecting_hom
    
    def plot_both(self, posvec):
        H2 = self.homology(2)
        pos = np.dot(H2, posvec)
        stress = np.dot(self.connecting_hom_2(),pos)
            
        if max(abs(stress)) > 0.000001: #Nondegenerate Picture
            fig, (ax1, ax2) = plt.subplots(1, 2)
            for i in range(0, self.cell_complex.num(0)):
                X = self.cell_complex.totcoords[i][0]
                Y = self.cell_complex.totcoords[i][1]
                ax1.text(X, Y, i)
                ax1.scatter(X,Y)

            for i in range(0, self.cell_complex.num(1)):
                edge = self.cell_complex.edges[i]
                edgex = [self.cell_complex.totcoords[edge[0], 0], self.cell_complex.totcoords[edge[1], 0] ]
                edgey = [self.cell_complex.totcoords[edge[0], 1], self.cell_complex.totcoords[edge[1], 1] ]
                centroid = self.cell_complex.edge_centroid(i)
                if stress[i] < -0.000001:
                    ax1.plot(edgex, edgey, color='blue')
                elif stress[i] > 0.000001:
                    ax1.plot(edgex, edgey, color='red')
                else:
                    ax1.plot(edgex, edgey, color = 'black')
                #ax.text(centroid[0], centroid[1], round(stress, 2) )
            
            #---------------------------------------
            
            X = np.zeros(self.cell_complex.num(2))
            Y = np.zeros(self.cell_complex.num(2))
            for i in range(0, self.cell_complex.num(2)):
                ccw = self.cell_complex.face_orientation(i)
                x,y = pos[2*i :2*(i+1)]
                X[i], Y[i] = np.real(x), np.real(y)
                if ccw:
                    X[i], Y[i] = -X[i], -Y[i]
            for i in range(0, self.cell_complex.num(1)):
                edge = self.cell_complex.edges[i]
                evect = np.zeros(self.cell_complex.num(1))
                evect[i] = 1
                fvect = np.dot(self.cell_complex.adj(2).T, evect.T)
                findex = [-1,-1] #Haven't adjacent faces yet
                count = 0
                for j in range(0, len(fvect)):
                    if abs(fvect[j]) > 0.1:
                        findex[count] = j
                        count += 1
                if findex[0] > -1 and findex[1] > -1:
                    ax2.plot(X[findex], Y[findex], color='black')
            for i in range(0,self.cell_complex.num(2)):
                ax2.text(X[i] + 0.0005*i,Y[i],i)
                ax2.scatter(X[i],Y[i])
            
            ax1.set_title('Primal')
            ax2.set_title('Dual')
            plt.show()
        else:
            print("Degenerate picture, stress is trivial")


#########################################################################################
### Group Action Cell Permutation Functions##############################################
#########################################################################################


def edge_permutation(action, edges, element):
        #Gives the permutation of (edges) under the (action) group (element) vertex permutation
        #The sign of the transformation is attatched
        permuted_edges = {}
        vert_action = action.vert_permutation(element) #The permutation of vertex indices
        for index in range(0, len(edges)):
            edge = edges[index]
            perm0, s1 = vert_action[edge[0]]
            perm1, s2 = vert_action[edge[1]]

            #Search for edge
            flag = False
            key = 0
            while not flag:
                if key in edges:
                    test_edge = edges[key]
                    if test_edge[0] == perm0:
                        if test_edge[1] == perm1:
                            permuted_edges[index] = (key, 1)
                            flag = True
                    elif test_edge[1] == perm0:
                        if test_edge[0] == perm1:
                            permuted_edges[index] = (key, -1)
                            flag = True
                    key += 1
                else:
                    print("Edge Permutation Error")
                    flag = True
        return permuted_edges

def face_permutation(action, faces, element):
    #Gives the permutation of (faces) under the (action) group (element) vertex permutation
    #The sign of the transformation is attatched
    permuted_faces = {}
    vert_action = action.vert_permutation(element)
    for index in range(0, len(faces)):
        face = faces[index]
        permed = [0] * len(face)
        #Permute the face-vertex indices
        for i in range(0, len(permed)):
            permed[i], s = vert_action[face[i]]
        #Search for face
        flag = False
        key = 0
        while not flag:
            if key in faces:
                test_face = faces[key]
                #Assume True, sequentially check at vertices if the test face ISN'T the permuted face
                is_the_face = True 
                for i in range(0, len(test_face)):
                    if test_face[i] in permed:
                        pass
                    else:
                        is_the_face = False

                #The permuted face is test_face, now get the correct orientation
                #permed = test_face
                if is_the_face:
                    flag = True
                    #Find the index of test face corresponding to the [0] index of the target test_face
                    base_index = 0
                    for j in range(0, len(test_face)):
                        if permed[j] == test_face[0]:
                            base_index = j
                            #index must be the valid vertex because we checked the face is correct
                    next_perm_index = permed[(base_index+1) % len(permed)]
                    next_test_index = test_face[1]
                    if next_test_index == next_perm_index:
                        permuted_faces[index] = (key, 1)
                    else:
                        permuted_faces[index] = (key, -1)
                key += 1
            else:
                print("Face Permutation Error")
                print("group element index:", element)
                print("face:", face)
                print("permuted face:", permed)
                flag = True
    return permuted_faces